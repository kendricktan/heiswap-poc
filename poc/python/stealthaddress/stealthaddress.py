"""
Stealth addresses in bitcoin

Basically a diffie-hellman with extra steps
"""

import hashlib
import functools
import ecdsa

from typing import Tuple, List, Union

from ecdsa import numbertheory, ellipticcurve
from ecdsa.curves import SECP256k1
from ecdsa.ecdsa import curve_secp256k1
from ecdsa.ellipticcurve import Point
from ecdsa.util import string_to_number, number_to_string, randrange

G = SECP256k1.generator
P = SECP256k1.order
hash_function = hashlib.sha256

Scalar = int


def hash_int(i: int) -> int:
    """
    Hashes int and returns 
    """
    return int(hash_function(str(i).encode('utf-8')).hexdigest(), 16)


def decode_int(b: bytes) -> int:
    return int(b, 16)


def random_scalar() -> Scalar:
    """
    Helper function

    Returns a random scalar (secret key)
    """
    return randrange(SECP256k1.order)


def serialize(*args) -> bytes:
    """
    Helper function

    Serializes all supplied arguments into bytes
    """
    b = b""

    for i in range(len(args)):
        if type(args[i]) is int:
            b += args[i].to_bytes(32, 'big')
        elif type(args[i]) is Point:
            b += args[i].x().to_bytes(32, 'big')
            b += args[i].y().to_bytes(32, 'big')
        elif type(args[i]) is str:
            b += args[i].encode('utf-8')
        elif type(args[i]) is bytes:
            b += args[i]
        elif type(args[i]) is list:
            b += serialize(*args[i])

    return b

# Alice wants to send stuff to Bob
# Bob has to generate a stealth address and send it to Alice


# Alice's secret key & public key
alice_sk = random_scalar()
alice_pk = G * alice_sk

# Bob's stealth address (need to be generated by client)
bob_spend_sk = random_scalar()
bob_view_sk = hash_int(bob_spend_sk)
bob_spend_pk = G * bob_spend_sk
bob_view_pk = G * bob_view_sk

# Alice generates a stealth address for Bob
random_sk = random_scalar()
random_pk = G * random_sk

d_partial = random_sk * bob_view_pk

# This has to do with n==0 mod 8 by definition, c.f.
# the top paragraph of page 5 of http://cr.yp.to/ecdh/curve25519-20060209.pdf
d = d_partial * 8

# Hash d to make it unlinkable
f_sk = decode_int(
    hash_function(serialize(d)).hexdigest()
)
f_pk = G * f_sk

# Stealth address = f_pk + spend_pk
stealth_address = f_pk + bob_spend_pk

# Alice publishes the stealth_pk along with the random_pk

# Given the random_pk and the stealth_pk
# Bob checks if the stealth address belongs to him
bob_d_partial = bob_view_sk * random_pk
bob_d = bob_d_partial * 8
bob_f_sk = decode_int(
    hash_function(serialize(bob_d)).hexdigest()
)
bob_f_pk = G * bob_f_sk
bob_stealth_address = bob_f_pk + bob_spend_pk

assert bob_stealth_address == stealth_address

# Construct the one-time private key associated with the stealth address
stealth_sk = bob_spend_sk + bob_f_sk

assert G * stealth_sk == stealth_address
